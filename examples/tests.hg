## fac funtions ##
# first line comments
fn fac(n) {
  if n <=1 { return 1 } else { return n * fac(n-1) }
}

# tail call version:
fn fac_tailcall(n) {
  fn f(acc, n) {
    if n <= 1 { return acc} else { return f(acc*n, n-1) }
  }
  return f(1, n)
}

## import modules ##
math = require("math") # -- math is a local number

math.add(3, 9) # 12
print(math.pi) # --> 3.14159

## global variables via table `G` ##
print = G.print # -- all modules share the same `G` table
G = {} # -- override global locally

greet = fn() {print("hello")}

## Car object ##
fn Car(speed) {
  car = {postion: 0}

  # -- methods of a object
  car.run = fn (time) { car.postion = car.postion + time }
  return car
}

car = Car(4)
car.run(3)
print(car.postion) # --> 12

## metatable ##
fn Base() {
  o = {}
  o.hello = fn () { return "hello from base" }
  return o
}

base = Base()

fn A() {
  a = {}
  setmeta(a, base)
  return a
}

a = A()
a.hello() # -- `hello` of base will be called

## access properties of sub object ##
fn Greeter(Namer) {
  o = {}
  o.greet = fn () { return "hello, " + Namer.name() }
  return o
}

fn Human(name) {
  o = {}
  G.setmeta(o, Greeter(o))
  o.name = fn () { return name }
  return o
}

a = Human("yangtao")
a.greet()

## functional ##
fn Fun(t) {
  m = {}
  setmeta(t, m)
  
  m.map = fn (f) {
    res = {}
    setmeta(res, m)
    for k, v in t {
      res[k] = f(v)
    }
    return res
  }
    
  m.filter = fn (f) {
    res = {}
    setmeta(res, m)
    for k, v in t {
      res[k] = f(v)
    }
    return res
  }
  
  return t
}

Fun({1, 2, 3, 4, 5, 6}).
    map(fn (x) {return x*x}).
    filter(fn (x) {return x>10})
#--> {16, 25, 36}


## special cases  ##
{hello: fn(){print("ho")}}.hello()

fn() { print("hello") } ()

fn() {
} ()

fn() {
  return fn(a) {print(a)}
} ()("hello")


t = {}
t[1], t.a = 1, fn(a) {print(a)}
t.a(t[1]) #--> 1
t[a](t[1]) #--> 1

_ = fn () {}

nested = {
  outer: {
    inner: {
        foo: fn (n) {x=n+100;print(x)}
    }
  }
}

nested[outer].inner[foo](100) #->> 100

# last line comments
